source('~/git/M9/setup.R')
library(fields)
library(rstan)
library(corpcor) # for fast computation of pseudoinverse
setwd("~/git/M9/")
source("taper.R")
source("okada.R")
source('predictions.R')
source('plotSubfault.R')
source('loadTestData.r')
source('fitModel.R')
source("loadFloodDat.R")
source("test.R")
source("exploratoryAnalysisFuns.R") # -418.9, 319
source("splines.R")
source("priors.R")
source("fitModel2.R")
library(splines)
library(abind)
library(numDeriv)
library(VGAM)
library(ggmap)
library(ggplot2)
library(scales)
library(RColorBrewer)
library(latex2exp)
library(maps)
library(mapdata)
library(gstat)
library(sp)
library(maptools)
library(gridExtra)
library(foreach)
library(doParallel)
# precompute G
nx = 300
ny=  900
lonGrid = seq(lonRange[1], lonRange[2], l=nx)
latGrid = seq(latRange[1], latRange[2], l=ny)
G = okadaAll(csz, lonGrid, latGrid, cbind(dr1$Lon, dr1$Lat), slip=1, poisson=0.25)
fauxG = getFauxG()
## set up down-dip slip limit and gps dataset: set threshold, match error with
## empirical estimates from Pollitz and Evans (2017)
depthThresh=21000
nKnots = 5
nKnotsGPS = 5
dStar=25000
set.seed(123)
threshSlipDat = slipDatCSZ[slipDatCSZ$Depth<depthThresh,]
threshSlipDat$slipErr = threshSlipDat$slipErr*3
minLat = min(c(csz$latitude, threshSlipDat$lat)) - .001
maxLat = max(c(csz$latitude, threshSlipDat$lat)) + .001
## calculate inflations for high and low quality subsidence data (under combined model)
highQual = as.numeric(dr1$quality) == 1
lowQual = as.numeric(dr1$quality) != 1
lowInflate=1.75
lowInflateComb=1.75
lowInflateDiff=1.75
highInflate=1.25
highInflateComb=1.25
highInflateDiff=1.25
inflateDr1=dr1
inflateDr1$Uncertainty[lowQual] = inflateDr1$Uncertainty[lowQual]*lowInflateComb
inflateDr1$Uncertainty[highQual] = inflateDr1$Uncertainty[highQual]*highInflateComb
load("finalFitCombRevised.RData")
load("finalFitDiff.RData")
fitGPS = fitSub = fitDiff
splinePar = fitGPS$optPar[3:(2+nKnots)]
splineParGPS = fitGPS$optPar[(3+nKnots):(2+nKnots+nKnotsGPS)]
Xi = getSplineBasis(csz, c(minLat, maxLat), nKnotsGPS)
fitGPS$tvec = c(taper(getFaultCenters(csz)[,3], Xi %*% (splinePar-splineParGPS), dStar=dStar, normalize=TRUE))
XiGPS = getSplineBasis(NULL, c(minLat, maxLat), nKnotsGPS, lats=threshSlipDat$lat)
fitSub$tvecGPS = c(taper(threshSlipDat$Depth, XiGPS %*% splinePar, dStar=dStar, normalize=TRUE))
fitComb$tvec = c(fitComb$tvec)
fitSub$tvec = c(fitSub$tvec)
fitList = list(fitComb, fitSub, fitGPS)
params = fitSub$MLEs
muZeta = params[2]
sigmaZeta = params[3]
tvec = fitSub$tvec
phiZeta = params[length(params) - 1]
alpha = params[length(params)]
out = straightenFaultLambert()
faultGeomStraight = out$fault
scale = out$scale
parameters = out$projPar
transformation = out$transformation
cszStraight = divideFault2(faultGeomStraight)
centers = getFaultCenters(csz)[,1:2]
newCenters = transformation(centers)
cszStraight$centerX = newCenters[,1]
cszStraight$centerY = newCenters[,2]
# calculate along strike and along dip squared distances in kilometers
strikeCoordsCSZ = cbind(0, cszStraight$centerY)
dipCoordsCSZ = cbind(cszStraight$centerX, 0)
squareStrikeDistCsz = rdist(strikeCoordsCSZ)^2
squareDipDistCsz = rdist(dipCoordsCSZ)^2
# compute gps, fault, and cross distance matrices
distMatCSZComb = sqrt(alpha^2 * squareStrikeDistCsz + alpha^(-2) * squareDipDistCsz)
load("adjustedMuCombRevised.RData")
# compute covariance matrix
# arealCSZCor = stationary.cov(cbind(csz$longitude, csz$latitude), Covariance="Matern",
#                              theta=params[length(params)], smoothness=3/2,
#                              Distance="rdist.earth", Dist.args=list(miles=FALSE))
# arealCSZCov = arealCSZCor * sigmaZeta^2
distMatCSZDiff = sqrt(alpha^2 * squareStrikeDistCsz + alpha^(-2) * squareDipDistCsz)
coordsCSZ = cbind(cszStraight$longitude, cszStraight$latitude)
arealCSZCor = stationary.cov(coordsCSZ, Covariance="Matern", theta=phiZeta,
smoothness=nuZeta, distMat = distMatCSZDiff)
nuZeta=3 / 2
arealCSZCor = stationary.cov(coordsCSZ, Covariance="Matern", theta=phiZeta,
smoothness=nuZeta, distMat = distMatCSZDiff)
arealCSZCov = arealCSZCor * sigmaZeta^2
# compute adjusted mean parameter
adjustedMuSub = getPosNormMu(muZeta, arealCSZCov, startN=nrow(csz), initNewMu=15)
### for subsidence marginal model:
# get the parameters
params = fitSub$MLEs
muZeta = params[2]
sigmaZeta = params[3]
tvec = fitSub$tvec
phiZeta = params[length(params) - 1]
alpha = params[length(params)]
nuZeta=3 / 2
# compute covariance matrix
# arealCSZCor = stationary.cov(cbind(csz$longitude, csz$latitude), Covariance="Matern",
#                              theta=params[length(params)], smoothness=3/2,
#                              Distance="rdist.earth", Dist.args=list(miles=FALSE))
# arealCSZCov = arealCSZCor * sigmaZeta^2
distMatCSZDiff = sqrt(alpha^2 * squareStrikeDistCsz + alpha^(-2) * squareDipDistCsz)
coordsCSZ = cbind(cszStraight$longitude, cszStraight$latitude)
arealCSZCor = stationary.cov(coordsCSZ, Covariance="Matern", theta=phiZeta,
smoothness=nuZeta, distMat = distMatCSZDiff)
arealCSZCov = arealCSZCor * sigmaZeta^2
muZeta
range(sqrt(diag(arealCSZCov)))
fitComb$MLEs
params = fitComb$MLEs
muZeta = params[2]
sigmaZeta = params[3]
tvec = fitComb$tvec
nuZeta=3 / 2
params = fitComb$MLEs
muZeta = params[2]
sigmaZeta = params[3]
alpha = params[length(params)]
phiZeta = params[length(params) - 1]
nuZeta=3 / 2
# arealCSZCor = stationary.cov(cbind(csz$longitude, csz$latitude), Covariance="Matern",
#                              theta=phiZeta, smoothness=3/2)
### Rather than training the fault, we redefine an axis to be the strike access in Euclidean space
### using a Lambert projection and PCA
out = straightenFaultLambert()
faultGeomStraight = out$fault
scale = out$scale
parameters = out$projPar
transformation = out$transformation
cszStraight = divideFault2(faultGeomStraight)
centers = getFaultCenters(csz)[,1:2]
newCenters = transformation(centers)
cszStraight$centerX = newCenters[,1]
cszStraight$centerY = newCenters[,2]
# calculate along strike and along dip squared distances in kilometers
strikeCoordsCSZ = cbind(0, cszStraight$centerY)
dipCoordsCSZ = cbind(cszStraight$centerX, 0)
squareStrikeDistCsz = rdist(strikeCoordsCSZ)^2
squareDipDistCsz = rdist(dipCoordsCSZ)^2
# compute gps, fault, and cross distance matrices
distMatCSZComb = sqrt(alpha^2 * squareStrikeDistCsz + alpha^(-2) * squareDipDistCsz)
coordsCSZ = cbind(cszStraight$longitude, cszStraight$latitude)
arealCSZCor = stationary.cov(coordsCSZ, Covariance="Matern", theta=phiZeta,
smoothness=nuZeta, distMat = distMatCSZComb)
arealCSZCov = arealCSZCor * sigmaZeta^2
pmvnorm(upper=rep(0, nrow(csz)), mean=rep(-muZeta, nrow(csz)), sigma=arealCSZCov, abseps=.00001) # P(all pos) = (fitComb: 0.555679, fitDiff: 0.8202905)
1- pmvnorm(upper=rep(0, nrow(csz)), mean=rep(-muZeta, nrow(csz)), sigma=arealCSZCov, abseps=.00001) # P(any neg) = (fitComb: 0.4457753, fitDiff: 0.1816371)
##### do a quick chisq test for the extra taper parameters
1-pchisq(2*(fitDiff$logLikMLE - fitComb$logLikMLE), 5) # p-value is numerically 0...
##### Could try naively adjusting mean of positive normal models and looking at those predictions here
### for combined marginal model:
# get the parameters
params = fitComb$MLEs
muZeta = params[2]
sigmaZeta = params[3]
tvec = fitComb$tvec
nuZeta=3 / 2
# compute adjusted mean parameter
adjustedMuComb = getPosNormMu(muZeta, arealCSZCov, startN=150, initNewMu=8)
test = adjustedMuComb
load("adjustedMuCombRevised.RData")
adjustedMuComb
test
adjustedMuComb=test
save(adjustedMuComb, file="adjustedMuCombRevised.RData")
load("adjustedMuCombRevised.RData")
tempPar = params
tempPar[2] = adjustedMuComb
ggComparePredsToSubs(tempPar, G=G, tvec=tvec, plotNameRoot="", nsim=5000,
subDat=inflateDr1, logScale=FALSE, fileNameRoot=paste0("combPNAdjustedRevised"),
fault=csz, normalModel=TRUE, posNormalModel=TRUE, useMVNApprox=FALSE,
taperedGPSDat=TRUE, dStar=dStar, normalizeTaper=TRUE, noTitle=TRUE,
anisotropic=TRUE)
ggComparePredsToSubs(params, G=G, tvec=tvec, plotNameRoot="", nsim=5000,
subDat=inflateDr1, logScale=FALSE, fileNameRoot=paste0("combPNUnadjustedRevised"),
fault=csz, normalModel=TRUE, posNormalModel=TRUE, useMVNApprox=FALSE,
taperedGPSDat=TRUE, dStar=dStar, normalizeTaper=TRUE, noTitle=TRUE,
anisotropic=TRUE)
ggComparePredsToSubs(params, G=G, tvec=tvec, plotNameRoot="", nsim=5000,
subDat=inflateDr1, logScale=FALSE, fileNameRoot=paste0("combNRevised"),
fault=csz, normalModel=TRUE, posNormalModel=FALSE, useMVNApprox=FALSE,
taperedGPSDat=TRUE, dStar=dStar, normalizeTaper=TRUE, noTitle=TRUE,
anisotropic=TRUE)
source('~/git/M9/setup.R')
source('~/git/M9/test.R')
source('~/git/M9/predictions.R')
source('~/git/M9/approxDistn.R')
source('~/git/M9/fitModel.R')
source('~/git/M9/fitModel.R')
1:5=1
test = 1:5
test[1:3=1]
test[1:3]=1
test
source('~/git/M9/fitModel.R')
source('~/git/M9/fitModel.R')
source('~/git/M9/fitModel.R')
source('~/git/M9/fitModel.R')
source('~/git/M9/fitModel.R')
source('~/git/M9/fitModel.R')
source('~/git/M9/fitModel.R')
source('~/git/M9/setup.R')
source('~/git/M9/fitModel.R')
source('~/git/M9/fitModel.R')
